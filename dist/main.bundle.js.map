{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://p2d-ts/./src/vec2.ts","webpack://p2d-ts/./src/shape.ts","webpack://p2d-ts/./src/body.ts","webpack://p2d-ts/./src/manifold.ts","webpack://p2d-ts/./src/main.ts","webpack://p2d-ts/./src/world.ts"],"sourcesContent":["export class Vec2 {\n  public x: number;\n  public y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  clone() {\n    return new Vec2(this.x, this.y);\n  }\n\n  static add(left: Vec2, right: number): Vec2;\n  static add(left: Vec2, right: Vec2): Vec2;\n  static add(left: Vec2, right: number | Vec2): Vec2 {\n    if (typeof right === \"number\") {\n      return new Vec2(left.x + right, left.y + right);\n    } else {\n      return new Vec2(left.x + right.x, left.y + right.y);\n    }\n  }\n\n  static equal(left: Vec2, right: Vec2): boolean {\n    return left.x === right.x && left.y === right.y;\n  }\n\n  static sub(left: Vec2, right: number): Vec2;\n  static sub(left: Vec2, right: Vec2): Vec2;\n  static sub(left: Vec2, right: number | Vec2): Vec2 {\n    if (typeof right === \"number\") {\n      return new Vec2(left.x - right, left.y - right);\n    } else {\n      return new Vec2(left.x - right.x, left.y - right.y);\n    }\n  }\n\n  static product(left: Vec2, right: number): Vec2 {\n    return new Vec2(left.x * right, left.y * right);\n  }\n\n  static dot(left: Vec2, right: Vec2): number {\n    return left.x * right.x + left.y * right.y;\n  }\n\n  static div(left: Vec2, right: number): Vec2 {\n    return new Vec2(left.x / right, left.y / right);\n  }\n\n  private static clampNumber(value: number, min: number, max: number) {\n    if (value < min) {\n      return min;\n    } else if (value > max) {\n      return max;\n    }\n    return value;\n  }\n\n  static clamp(value: Vec2, min: Vec2, max: Vec2) {\n    return new Vec2(\n      Vec2.clampNumber(value.x, min.x, max.x),\n      Vec2.clampNumber(value.y, min.y, max.y)\n    );\n  }\n\n  static minus(vec: Vec2) {\n    return new Vec2(-vec.x, -vec.y);\n  }\n\n  equal(right: Vec2) {\n    return this.x === right.x && this.y === right.y;\n  }\n\n  normalize() {\n    const length = this.distance();\n    this.x /= length;\n    this.y /= length;\n    if (isNaN(this.x) || isNaN(this.y)) {\n      console.error(\"Alert!!!!\");\n    }\n  }\n\n  lenSqr(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance() {\n    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n  }\n}\n","import { Vec2 } from \"./vec2\";\n\nexport enum ShapeType {\n  Circle,\n  AABB,\n}\n\nexport interface Shape {\n    readonly shapeType: ShapeType;\n    readonly density: number;\n    computeMass: () => number;\n}\n\nexport class Circle implements Shape {\n    private radius: number;\n    shapeType: ShapeType = ShapeType.Circle;\n    density = 1.0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    computeMass() {\n        return Math.PI * Math.pow(this.radius, 2) * this.density;\n    }\n\n    getRadius() {\n        return this.radius;\n    }\n}\n\nexport class AABB implements Shape {\n    max: Vec2;\n    min: Vec2;\n\n    shapeType: ShapeType = ShapeType.AABB;\n    density: number = 3.0;\n\n    constructor(min: Vec2, max: Vec2) {\n        this.max = max.clone();\n        this.min = min.clone();\n    }\n\n    getCenter() {\n        return Vec2.div(Vec2.add(this.min, this.max), 2);\n    }\n\n    computeMass() {\n        const sub = Vec2.sub(this.max, this.min);\n        return sub.x * sub.y * this.density;\n    }\n}\n","import { AABB, Circle, Shape, ShapeType } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\n\nexport class Body {\n  shape: Shape;\n  position: Vec2;\n  velocity: Vec2 = new Vec2(0, 0);\n  static_fraction: number = 0.1;  // 静摩擦系数\n  dynamic_fraction: number = 0.05; // 动摩擦系数\n  restitution: number = 1;\n  force: Vec2 = new Vec2(0, 0);\n\n  mass: number; // 质量\n  inverse_mass: number; // 质量的倒数\n\n  constructor(shape: Shape, position: Vec2, restitution: number) {\n    this.shape = shape;\n    this.position = position;\n    this.restitution = restitution;\n    this.mass = shape.computeMass();\n    this.inverse_mass = this.mass !== 0 ? 1 / this.mass : 0;\n    console.log(`inverse mass = ${this.inverse_mass}`);\n  }\n\n  applyForce(f: Vec2) {\n    this.force = Vec2.add(this.force, f);\n  }\n\n  applyImpulse(impulse: Vec2) {\n    console.log(`this.iverse_mass = ${this.inverse_mass}`);\n    console.log(`product = ${impulse.x * this.inverse_mass}`);\n    this.velocity = Vec2.add(\n      this.velocity,\n      Vec2.product(impulse, this.inverse_mass)\n    );\n  }\n\n  makeStatic() {\n    this.mass = 0;\n    this.inverse_mass = 0;\n  }\n\n  private renderCircle(ctx: CanvasRenderingContext2D, circle: Circle) {\n    ctx.beginPath();\n    ctx.fillStyle = \"rgb(235, 235, 235)\";\n    ctx.arc(this.position.x, this.position.y, circle.getRadius(), 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private renderAABB(ctx: CanvasRenderingContext2D, rect: AABB) {\n    ctx.beginPath();\n    ctx.fillStyle = \"rgb(72, 77, 116)\";\n    \n    const halfExtend = Vec2.div(Vec2.sub(rect.max, rect.min), 2);\n    const leftTop = Vec2.sub(this.position, halfExtend);\n    ctx.fillRect(leftTop.x, leftTop.y, halfExtend.x * 2, halfExtend.y * 2);\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    switch (this.shape.shapeType) {\n      case ShapeType.Circle:\n        this.renderCircle(ctx, this.shape as Circle);\n        break;\n      case ShapeType.AABB:\n        this.renderAABB(ctx, this.shape as AABB);\n        break;\n    }\n  }\n}\n","import { Body } from \"./body\";\nimport { AABB, Circle, ShapeType } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\n\ntype DispatchFunction = (m: Manifold, a: Body, b: Body) => void;\nconst DISPATCHER: Map<ShapeType, Map<ShapeType, DispatchFunction>> = new Map([\n  [\n    ShapeType.Circle,\n    new Map([\n      [ShapeType.Circle, circle2circle],\n      [ShapeType.AABB, circle2AABB],\n    ]),\n  ],\n  [\n    ShapeType.AABB,\n    new Map([\n      [ShapeType.Circle, AABB2circle],\n      [ShapeType.AABB, AABB2AABB],\n    ]),\n  ],\n]);\n\nexport class Manifold {\n  a: Body;\n  b: Body;\n\n  normal: Vec2 = new Vec2(0, 1); // 单位向量，碰撞法线，表明两个物体的碰撞方向，在我们的物理引擎中采用相对于 B 的碰撞方向\n  penetration: number = 0;\n  e: number = 0; // 计算后的恢复系数\n  df: number = 0; // 计算后的动摩擦力\n  sf: number = 0; // 计算后的静摩擦力\n  contacts: Array<Vec2> = []; // 碰撞发生的位置\n\n  constructor(a: Body, b: Body) {\n    this.a = a;\n    this.b = b;\n  }\n\n  // 生成碰撞信息\n  solve() {\n    const func = DISPATCHER.get(this.a.shape.shapeType)?.get(\n      this.b.shape.shapeType\n    );\n    if (func) {\n      func(this, this.a, this.b);\n    } else {\n      throw Error(\"Invalid shape type\");\n    }\n  }\n\n  // 计算一些冲量求解的过程中需要的数据\n  initialize() {\n    this.e = Math.min(this.a.restitution, this.b.restitution);\n    // this.sf = this.a.static_fraction;\n    // this.df = this.b.static_fraction;\n    this.sf = Math.sqrt(this.a.static_fraction * this.a.static_fraction + this.b.static_fraction * this.b.static_fraction);\n    this.df = Math.sqrt(this.a.dynamic_fraction * this.a.dynamic_fraction + this.b.dynamic_fraction * this.b.dynamic_fraction);\n  }\n\n  applyImpulse() {\n    if (Math.abs(this.a.inverse_mass + this.b.inverse_mass) < 0.00001) {\n      // 两个物体的质量都无穷大\n      this.infiniteMassCorrection();\n      return;\n    }\n    // for (const contanct of this.contacts) {\n    // 相对速度在碰撞法线方向的分量\n    const rv = Vec2.dot(\n      Vec2.sub(this.b.velocity, this.a.velocity),\n      this.normal\n    );\n    if (rv > 0) {\n      // 物体有分离的趋势\n      return;\n    }\n    const inv_mass_sum = this.a.inverse_mass + this.b.inverse_mass;\n    // 计算冲量\n    let j = -(1.0 + this.e) * rv;\n    j /= inv_mass_sum;\n\n    const impulse = Vec2.product(this.normal, j);\n    this.a.applyImpulse(Vec2.minus(impulse));\n    this.b.applyImpulse(impulse);\n\n    // 应用摩擦力\n    const rv_2 = Vec2.sub(this.b.velocity, this.a.velocity);\n    const t = Vec2.sub(rv_2, Vec2.product(this.normal, Vec2.dot(rv_2, this.normal)));\n    // 如果 t 为 0，不需要计算摩擦力\n    if (Math.abs(t.lenSqr() - 0.0) <= 0.0001) {\n      return;\n    }\n    // console.log('t = ', t);\n    t.normalize();\n    // 计算切线方向的冲量幅值\n    let jt = -Vec2.dot(rv_2, t);\n    jt /= inv_mass_sum;\n    // jt /= contact_num;\n    if (Math.abs(jt - 0) < 0.00001) {\n      return;\n    }\n    console.log(`computed jt = ${jt}, j = ${j}`);\n    // 库仑定律\n    let tangent_impulse: Vec2;\n    if (Math.abs(jt) < j * this.sf) {\n      tangent_impulse = Vec2.product(t, jt);\n    } else {\n      tangent_impulse = Vec2.product(t, -j * this.df);\n    }\n    console.log(`tangent_impulse = (${tangent_impulse.x}, ${tangent_impulse.y})`);\n    this.a.applyImpulse(Vec2.minus(tangent_impulse));\n    this.b.applyImpulse(tangent_impulse);\n\n    // }\n  }\n\n  positionalCorrection() {\n    // const kSlop = 0.05; // Penetration allowance\n    // const percent = 0.4; // Penetration percentage to correct\n    // const correction = Vec2.product(this.normal, (Math.max(this.penetration - kSlop, 0) / (this.a.inverse_mass + this.b.inverse_mass)) * percent);\n    // this.a.position = Vec2.add(this.a.position, Vec2.product(correction, this.a.inverse_mass));\n    // this.b.position = Vec2.add(this.b.position, Vec2.product(correction, this.b.inverse_mass));\n  }\n\n  private infiniteMassCorrection() {\n    this.a.velocity = new Vec2(0, 0);\n    this.b.velocity = new Vec2(0, 0);\n  }\n}\n\nfunction circle2circle(m: Manifold, a: Body, b: Body) {\n  const circleA = a.shape as Circle;\n  const circleB = b.shape as Circle;\n  const n = Vec2.sub(b.position, a.position);\n  const r = circleA.getRadius() + circleB.getRadius();\n  const dist_sqr = n.lenSqr();\n  if (dist_sqr >= r * r) {\n    // 无碰撞发生\n    return;\n  }\n  const dist = Math.sqrt(dist_sqr);\n  if (dist === 0) {\n    // 两个圆处于同一位置\n    m.penetration = circleA.getRadius();\n    m.normal = new Vec2(1, 0);\n    m.contacts.push(a.position);\n  } else {\n    m.penetration = r - dist;\n    m.normal = Vec2.div(n, dist);\n    // 相对于 A 来说的碰撞点位置\n    m.contacts.push(\n      Vec2.add(Vec2.product(m.normal, circleA.getRadius()), a.position)\n    );\n  }\n}\nfunction circle2AABB(m: Manifold, a: Body, b: Body) {\n  AABB2circle(m, b, a);\n  m.normal = Vec2.minus(m.normal);\n}\nfunction AABB2AABB(m: Manifold, a: Body, b: Body) {\n  const firstAABB = a.shape as AABB;\n  const secondAABB = b.shape as AABB;\n\n  const n = Vec2.sub(b.position, a.position);\n  let aExtent = (firstAABB.max.x - firstAABB.min.x) / 2;\n  let bExtent = (secondAABB.max.x - secondAABB.min.x) / 2;\n  const xOverlap = aExtent + bExtent - Math.abs(n.x);\n  if (xOverlap > 0) {\n    aExtent = (firstAABB.max.y - firstAABB.min.y) / 2;\n    bExtent = (secondAABB.max.y - secondAABB.min.y) / 2;\n    const yOverlap = aExtent + bExtent - Math.abs(n.y);\n    if (yOverlap > 0) {\n      // 重叠小的方向是碰撞发生的方向\n      if (xOverlap < yOverlap) {\n        if (n.x < 0) {\n          m.normal = new Vec2(-1, 0);\n        } else {\n          m.normal = new Vec2(1, 0);\n        }\n        m.penetration = xOverlap;\n      } else {\n        if (n.y < 0) {\n          m.normal = new Vec2(0, -1);\n        } else {\n          m.normal = new Vec2(0, 1);\n        }\n        m.penetration = yOverlap;\n      }\n      m.contacts.push(new Vec2(0, 0));\n    }\n  }\n}\nfunction AABB2circle(m: Manifold, a: Body, b: Body) {\n  // https://www.zhihu.com/question/24251545\n  // FIXME: 当小球的速度过快，在一次计算的时间内冲入到 AABB 的内部时会出现normal出错的bug\n  const aabb = a.shape as AABB;\n  const circle = b.shape as Circle;\n  let difference = Vec2.sub(b.position, a.position);\n  const halfExtend = Vec2.div(Vec2.sub(aabb.max, aabb.min), 2);\n\n  const clamped = Vec2.clamp(difference, Vec2.minus(halfExtend), halfExtend);\n  const closet = Vec2.add(a.position, clamped);\n  difference = Vec2.sub(closet, b.position);\n  if (difference.lenSqr() < circle.getRadius() * circle.getRadius()) {\n    m.contacts.push(closet);\n    if (Vec2.equal(b.position, closet)) {\n      console.error(\"Equal sub\");\n    }\n    m.normal = Vec2.sub(b.position, closet);\n    m.normal.normalize();\n    m.penetration = 0;\n  }\n\n  // let inside = false;\n  // if (closet.equal(n)) {\n  //   // 圆心位于 AABB 内部\n  //   inside = true;\n  //   if (Math.abs(n.x) > Math.abs(n.y)) {\n  //     if (closet.x > 0) {\n  //       closet.x = halfExtend.x;\n  //     } else {\n  //       closet.x = -halfExtend.x;\n  //     }\n  //   } else {\n  //     if (closet.y > 0) {\n  //       closet.y = halfExtend.y;\n  //     } else {\n  //       closet.y = -halfExtend.y;\n  //     }\n  //   }\n  // }\n  // const normal = Vec2.sub(n, closet);\n  // let d = normal.lenSqr();\n  // const r = circle.getRadius();\n  // if (d > r * r && !inside) {\n  //   return;\n  // }\n  // m.contacts.push(closet);\n  // d = Math.sqrt(d);\n  // if (inside) {\n  //   m.normal = Vec2.minus(n);\n  //   m.penetration = r - d;\n  // } else {\n  //   m.normal = n;\n  //   m.penetration = r - d;\n  // }\n}\n","import { Body } from \"./body\";\nimport { AABB, Circle } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\nimport { World } from \"./world\";\n\nconst canvas = document.querySelector(\".scene\") as HTMLCanvasElement;\nconst ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\ncanvas.width = 480;\ncanvas.height = 800;\n\nconst world = new World(1 / 60, 20);\n\naddBorder();\n\nconst renderLoop = () => {\n    ctx.fillStyle = \"rgb(45, 64, 108)\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    world.step();\n    for (const body of world.getBodies()) {\n        body.render(ctx);\n    }\n    requestAnimationFrame(renderLoop);\n};\n\nrenderLoop();\n\ncanvas.addEventListener(\"mousedown\", (e) => {\n    if (e.button === 0) {\n        // 左键被按下，在按下的位置生成一个Ball\n        const rect = canvas.getBoundingClientRect();\n        const ballPosition = new Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        world.add(new Body(new Circle(30), ballPosition, 1.0));\n    } else if (e.button === 2) {\n        // 右键被按下，在按下的位置生成一个AABB\n        const rect = canvas.getBoundingClientRect();\n        const pos = new Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        const aabb = new AABB(new Vec2(0, 0), new Vec2(60, 60));\n        world.add(new Body(aabb, pos, 1.0));\n    }\n});\n\nfunction addBorder() {\n    const bottomHeight = 20;\n    const otherHeight = 10;\n    const topBorderAABB = new AABB(new Vec2(0, 0), new Vec2(canvas.width, otherHeight));\n    const topBorderground = new Body(topBorderAABB, topBorderAABB.getCenter(), 0.5);\n    topBorderground.makeStatic();\n    world.add(topBorderground);\n    const bottomBorderAABB = new AABB(new Vec2(0, canvas.height - bottomHeight), new Vec2(canvas.width, canvas.height));\n    const bottomBorderGround = new Body(bottomBorderAABB, bottomBorderAABB.getCenter(), 0.5);\n    bottomBorderGround.makeStatic();\n    world.add(bottomBorderGround);\n    const leftBorderAABB = new AABB(new Vec2(0, otherHeight), new Vec2(otherHeight, canvas.height - bottomHeight));\n    const leftBorderAABBGround = new Body(leftBorderAABB, leftBorderAABB.getCenter(), 0.5);\n    leftBorderAABBGround.makeStatic();\n    world.add(leftBorderAABBGround);\n    const rightBorderAABB = new AABB(new Vec2(canvas.width - otherHeight, otherHeight), new Vec2(canvas.width, canvas.height - bottomHeight));\n    const rightBorderGround = new Body(rightBorderAABB, rightBorderAABB.getCenter(), 0.5);\n    rightBorderGround.makeStatic();\n    world.add(rightBorderGround);\n}\n","import { Body } from \"./body\";\nimport { Manifold } from \"./manifold\";\nimport { Vec2 } from \"./vec2\";\n\nexport class World {\n  private dt: number;\n  private iterations: number;\n  private bodies: Array<Body> = [];\n  private contacts: Array<Manifold> = [];\n  private gravityScale = 10.0;\n  private gravity = new Vec2(0, 10.0 * this.gravityScale);\n\n  constructor(dt: number, iterations: number) {\n    this.dt = dt;\n    this.iterations = iterations;\n  }\n\n  getBodies() {\n    return this.bodies;\n  }\n\n  step() {\n    this.contacts.length = 0;\n    // 碰撞检测\n    for (let i = 0; i < this.bodies.length; ++i) {\n      const a = this.bodies[i];\n      for (let j = i + 1; j < this.bodies.length; ++j) {\n        const b = this.bodies[j];\n        if (a.inverse_mass === 0 && b.inverse_mass === 0) {\n          // 两个物体的质量都是无穷大，都不会挪动了\n          continue;\n        }\n        const m = new Manifold(a, b);\n        m.solve();\n        if (m.contacts.length > 0) {\n          this.contacts.push(m);\n        }\n      }\n    }\n\n    for (let i = 0; i < this.bodies.length; ++i) {\n      this.integrateForces(this.bodies[i], this.dt);\n    }\n\n    for (let i = 0; i < this.contacts.length; ++i) {\n      this.contacts[i].initialize();\n    }\n\n    for (let j = 0; j < this.iterations; ++j) {\n      for (let i = 0; i < this.contacts.length; ++i) {\n        this.contacts[i].applyImpulse();\n      }\n    }\n\n    for (const body of this.bodies) {\n      this.integrateVelocity(body, this.dt);\n    }\n\n    // 校正位置\n    for (const contact of this.contacts) {\n      contact.positionalCorrection();\n    }\n\n    // 清除所有受力\n    for (const body of this.bodies) {\n      body.force = new Vec2(0, 0);\n    }\n  }\n\n  add(body: Body) {\n    this.bodies.push(body);\n  }\n\n  getContacts() {\n    return this.contacts;\n  }\n\n  private integrateForces(body: Body, dt: number) {\n    if (body.inverse_mass === 0) {\n      return;\n    }\n\n    body.velocity = Vec2.add(\n      body.velocity,\n      Vec2.product(\n        Vec2.add(Vec2.product(body.force, body.inverse_mass), this.gravity),\n        dt / 2\n      )\n    );\n  }\n\n  private integrateVelocity(body: Body, dt: number) {\n    if (body.inverse_mass === 0) {\n      return;\n    }\n    body.position = Vec2.add(body.position, Vec2.product(body.velocity, dt));\n    // TODO: Why ??\n    this.integrateForces(body, dt);\n  }\n}\n"],"names":["Vec2","constructor","x","y","this","clone","add","left","right","equal","sub","product","dot","div","clampNumber","value","min","max","clamp","minus","vec","normalize","length","distance","isNaN","console","error","lenSqr","Math","sqrt","pow","ShapeType","Circle","radius","shapeType","density","computeMass","PI","getRadius","AABB","getCenter","Body","shape","position","restitution","velocity","static_fraction","dynamic_fraction","force","mass","inverse_mass","log","applyForce","f","applyImpulse","impulse","makeStatic","renderCircle","ctx","circle","beginPath","fillStyle","arc","fill","renderAABB","rect","halfExtend","leftTop","fillRect","render","DISPATCHER","Map","m","a","b","circleA","circleB","n","r","dist_sqr","dist","penetration","normal","contacts","push","AABB2circle","firstAABB","secondAABB","aExtent","bExtent","xOverlap","abs","yOverlap","Manifold","e","df","sf","solve","func","get","Error","initialize","infiniteMassCorrection","rv","inv_mass_sum","j","rv_2","t","tangent_impulse","jt","positionalCorrection","aabb","difference","clamped","closet","canvas","document","querySelector","getContext","width","height","world","dt","iterations","bodies","gravityScale","gravity","getBodies","step","i","integrateForces","body","integrateVelocity","contact","getContacts","topBorderAABB","topBorderground","bottomBorderAABB","bottomBorderGround","leftBorderAABB","leftBorderAABBGround","rightBorderAABB","rightBorderGround","addBorder","renderLoop","requestAnimationFrame","addEventListener","button","getBoundingClientRect","ballPosition","clientX","clientY","top","pos"],"sourceRoot":""}