{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://p2d-ts/./src/vec2.ts","webpack://p2d-ts/./src/shape.ts","webpack://p2d-ts/./src/body.ts","webpack://p2d-ts/./src/manifold.ts","webpack://p2d-ts/./src/main.ts","webpack://p2d-ts/./src/world.ts"],"sourcesContent":["export class Vec2 {\n  public x: number;\n  public y: number;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  clone() {\n    return new Vec2(this.x, this.y);\n  }\n\n  static add(left: Vec2, right: number): Vec2;\n  static add(left: Vec2, right: Vec2): Vec2;\n  static add(left: Vec2, right: number | Vec2): Vec2 {\n    if (typeof right === \"number\") {\n      return new Vec2(left.x + right, left.y + right);\n    } else {\n      return new Vec2(left.x + right.x, left.y + right.y);\n    }\n  }\n\n  static equal(left: Vec2, right: Vec2): boolean {\n    return left.x === right.x && left.y === right.y;\n  }\n\n  static sub(left: Vec2, right: number): Vec2;\n  static sub(left: Vec2, right: Vec2): Vec2;\n  static sub(left: Vec2, right: number | Vec2): Vec2 {\n    if (typeof right === \"number\") {\n      return new Vec2(left.x - right, left.y - right);\n    } else {\n      return new Vec2(left.x - right.x, left.y - right.y);\n    }\n  }\n\n  static product(left: Vec2, right: number): Vec2 {\n    return new Vec2(left.x * right, left.y * right);\n  }\n\n  static dot(left: Vec2, right: Vec2): number {\n    return left.x * right.x + left.y * right.y;\n  }\n\n  static div(left: Vec2, right: number): Vec2 {\n    return new Vec2(left.x / right, left.y / right);\n  }\n\n  private static clampNumber(value: number, min: number, max: number) {\n    if (value < min) {\n      return min;\n    } else if (value > max) {\n      return max;\n    }\n    return value;\n  }\n\n  static clamp(value: Vec2, min: Vec2, max: Vec2) {\n    return new Vec2(\n      Vec2.clampNumber(value.x, min.x, max.x),\n      Vec2.clampNumber(value.y, min.y, max.y)\n    );\n  }\n\n  static minus(vec: Vec2) {\n    return new Vec2(-vec.x, -vec.y);\n  }\n\n  equal(right: Vec2) {\n    return this.x === right.x && this.y === right.y;\n  }\n\n  normalize() {\n    const length = this.distance();\n    this.x /= length;\n    this.y /= length;\n    if (isNaN(this.x) || isNaN(this.y)) {\n      console.error(\"Alert!!!!\");\n    }\n  }\n\n  lenSqr(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance() {\n    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n  }\n}\n","import { Vec2 } from \"./vec2\";\n\nexport enum ShapeType {\n  Circle,\n  AABB,\n}\n\nexport interface Shape {\n    readonly shapeType: ShapeType;\n    readonly density: number;\n    computeMass: () => number;\n}\n\nexport class Circle implements Shape {\n    private radius: number;\n    shapeType: ShapeType = ShapeType.Circle;\n    density = 1.0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    computeMass() {\n        return Math.PI * Math.pow(this.radius, 2) * this.density;\n    }\n\n    getRadius() {\n        return this.radius;\n    }\n}\n\nexport class AABB implements Shape {\n    max: Vec2;\n    min: Vec2;\n\n    shapeType: ShapeType = ShapeType.AABB;\n    density: number = 3.0;\n\n    constructor(min: Vec2, max: Vec2) {\n        this.max = max.clone();\n        this.min = min.clone();\n    }\n\n    getCenter() {\n        return Vec2.div(Vec2.add(this.min, this.max), 2);\n    }\n\n    computeMass() {\n        const sub = Vec2.sub(this.max, this.min);\n        return sub.x * sub.y * this.density;\n    }\n}\n","import { AABB, Circle, Shape, ShapeType } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\n\nexport class Body {\n  shape: Shape;\n  position: Vec2;\n  velocity: Vec2 = new Vec2(0, 0);\n  restitution: number = 1;\n  force: Vec2 = new Vec2(0, 0);\n\n  mass: number; // 质量\n  inverse_mass: number; // 质量的倒数\n\n  constructor(shape: Shape, position: Vec2, restitution: number) {\n    this.shape = shape;\n    this.position = position;\n    this.restitution = restitution;\n    this.mass = shape.computeMass();\n    this.inverse_mass = this.mass !== 0 ? 1 / this.mass : 0;\n  }\n\n  applyForce(f: Vec2) {\n    this.force = Vec2.add(this.force, f);\n  }\n\n  applyImpulse(impulse: Vec2) {\n    this.velocity = Vec2.add(\n      this.velocity,\n      Vec2.product(impulse, this.inverse_mass)\n    );\n  }\n\n  makeStatic() {\n    this.mass = 0;\n    this.inverse_mass = 0;\n  }\n\n  private renderCircle(ctx: CanvasRenderingContext2D, circle: Circle) {\n    ctx.beginPath();\n    ctx.fillStyle = \"rgb(235, 235, 235)\";\n    ctx.arc(this.position.x, this.position.y, circle.getRadius(), 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private renderAABB(ctx: CanvasRenderingContext2D, rect: AABB) {\n    ctx.beginPath();\n    ctx.fillStyle = \"rgb(72, 77, 116)\";\n    \n    const halfExtend = Vec2.div(Vec2.sub(rect.max, rect.min), 2);\n    const leftTop = Vec2.sub(this.position, halfExtend);\n    ctx.fillRect(leftTop.x, leftTop.y, halfExtend.x * 2, halfExtend.y * 2);\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    switch (this.shape.shapeType) {\n      case ShapeType.Circle:\n        this.renderCircle(ctx, this.shape as Circle);\n        break;\n      case ShapeType.AABB:\n        this.renderAABB(ctx, this.shape as AABB);\n        break;\n    }\n  }\n}\n","import { Body } from \"./body\";\nimport { AABB, Circle, ShapeType } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\n\ntype DispatchFunction = (m: Manifold, a: Body, b: Body) => void;\nconst DISPATCHER: Map<ShapeType, Map<ShapeType, DispatchFunction>> = new Map([\n  [\n    ShapeType.Circle,\n    new Map([\n      [ShapeType.Circle, circle2circle],\n      [ShapeType.AABB, circle2AABB],\n    ]),\n  ],\n  [\n    ShapeType.AABB,\n    new Map([\n      [ShapeType.Circle, AABB2circle],\n      [ShapeType.AABB, AABB2AABB],\n    ]),\n  ],\n]);\n\nexport class Manifold {\n  a: Body;\n  b: Body;\n\n  normal: Vec2 = new Vec2(0, 1); // 单位向量，碰撞法线，表明两个物体的碰撞方向，在我们的物理引擎中采用相对于 B 的碰撞方向\n  penetration: number = 0;\n  e: number = 0; // 计算后的恢复系数\n  contacts: Array<Vec2> = []; // 碰撞发生的位置\n\n  constructor(a: Body, b: Body) {\n    this.a = a;\n    this.b = b;\n  }\n\n  // 生成碰撞信息\n  solve() {\n    const func = DISPATCHER.get(this.a.shape.shapeType)?.get(\n      this.b.shape.shapeType\n    );\n    if (func) {\n      func(this, this.a, this.b);\n    } else {\n      throw Error(\"Invalid shape type\");\n    }\n  }\n\n  // 计算一些冲量求解的过程中需要的数据\n  initialize() {\n    this.e = Math.min(this.a.restitution, this.b.restitution);\n  }\n\n  applyImpulse() {\n    if (Math.abs(this.a.inverse_mass + this.b.inverse_mass) < 0.00001) {\n      // 两个物体的质量都无穷大\n      this.infiniteMassCorrection();\n      return;\n    }\n    // for (const contanct of this.contacts) {\n    // 相对速度在碰撞法线方向的分量\n    const rv = Vec2.dot(\n      Vec2.sub(this.b.velocity, this.a.velocity),\n      this.normal\n    );\n    if (rv > 0) {\n      // 物体有分离的趋势\n      return;\n    }\n    const inv_mass_sum = this.a.inverse_mass + this.b.inverse_mass;\n    // 计算冲量\n    let j = -(1.0 + this.e) * rv;\n    j /= inv_mass_sum;\n\n    const impulse = Vec2.product(this.normal, j);\n    this.a.applyImpulse(Vec2.minus(impulse));\n    this.b.applyImpulse(impulse);\n    // }\n  }\n\n  positionalCorrection() {\n    // const kSlop = 0.05; // Penetration allowance\n    // const percent = 0.4; // Penetration percentage to correct\n    // const correction = Vec2.product(this.normal, (Math.max(this.penetration - kSlop, 0) / (this.a.inverse_mass + this.b.inverse_mass)) * percent);\n    // this.a.position = Vec2.add(this.a.position, Vec2.product(correction, this.a.inverse_mass));\n    // this.b.position = Vec2.add(this.b.position, Vec2.product(correction, this.b.inverse_mass));\n  }\n\n  private infiniteMassCorrection() {\n    this.a.velocity = new Vec2(0, 0);\n    this.b.velocity = new Vec2(0, 0);\n  }\n}\n\nfunction circle2circle(m: Manifold, a: Body, b: Body) {\n  const circleA = a.shape as Circle;\n  const circleB = b.shape as Circle;\n  const n = Vec2.sub(b.position, a.position);\n  const r = circleA.getRadius() + circleB.getRadius();\n  const dist_sqr = n.lenSqr();\n  if (dist_sqr >= r * r) {\n    // 无碰撞发生\n    return;\n  }\n  const dist = Math.sqrt(dist_sqr);\n  if (dist === 0) {\n    // 两个圆处于同一位置\n    m.penetration = circleA.getRadius();\n    m.normal = new Vec2(1, 0);\n    m.contacts.push(a.position);\n  } else {\n    m.penetration = r - dist;\n    m.normal = Vec2.div(n, dist);\n    // 相对于 A 来说的碰撞点位置\n    m.contacts.push(\n      Vec2.add(Vec2.product(m.normal, circleA.getRadius()), a.position)\n    );\n  }\n}\nfunction circle2AABB(m: Manifold, a: Body, b: Body) {\n  AABB2circle(m, b, a);\n  m.normal = Vec2.minus(m.normal);\n}\nfunction AABB2AABB(m: Manifold, a: Body, b: Body) {\n  const firstAABB = a.shape as AABB;\n  const secondAABB = b.shape as AABB;\n\n  const n = Vec2.sub(b.position, a.position);\n  let aExtent = (firstAABB.max.x - firstAABB.min.x) / 2;\n  let bExtent = (secondAABB.max.x - secondAABB.min.x) / 2;\n  const xOverlap = aExtent + bExtent - Math.abs(n.x);\n  if (xOverlap > 0) {\n    aExtent = (firstAABB.max.y - firstAABB.min.y) / 2;\n    bExtent = (secondAABB.max.y - secondAABB.min.y) / 2;\n    const yOverlap = aExtent + bExtent - Math.abs(n.y);\n    if (yOverlap > 0) {\n      // 重叠小的方向是碰撞发生的方向\n      if (xOverlap < yOverlap) {\n        if (n.x < 0) {\n          m.normal = new Vec2(-1, 0);\n        } else {\n          m.normal = new Vec2(1, 0);\n        }\n        m.penetration = xOverlap;\n      } else {\n        if (n.y < 0) {\n          m.normal = new Vec2(0, -1);\n        } else {\n          m.normal = new Vec2(0, 1);\n        }\n        m.penetration = yOverlap;\n      }\n      m.contacts.push(new Vec2(0, 0));\n    }\n  }\n}\nfunction AABB2circle(m: Manifold, a: Body, b: Body) {\n  // https://www.zhihu.com/question/24251545\n  // FIXME: 当小球的速度过快，在一次计算的时间内冲入到 AABB 的内部时会出现normal出错的bug\n  const aabb = a.shape as AABB;\n  const circle = b.shape as Circle;\n  let difference = Vec2.sub(b.position, a.position);\n  const halfExtend = Vec2.div(Vec2.sub(aabb.max, aabb.min), 2);\n\n  const clamped = Vec2.clamp(difference, Vec2.minus(halfExtend), halfExtend);\n  const closet = Vec2.add(a.position, clamped);\n  difference = Vec2.sub(closet, b.position);\n  if (difference.lenSqr() < circle.getRadius() * circle.getRadius()) {\n    m.contacts.push(closet);\n    if (Vec2.equal(b.position, closet)) {\n      console.error(\"Equal sub\");\n    }\n    m.normal = Vec2.sub(b.position, closet);\n    m.normal.normalize();\n    m.penetration = 0;\n  }\n\n  // let inside = false;\n  // if (closet.equal(n)) {\n  //   // 圆心位于 AABB 内部\n  //   inside = true;\n  //   if (Math.abs(n.x) > Math.abs(n.y)) {\n  //     if (closet.x > 0) {\n  //       closet.x = halfExtend.x;\n  //     } else {\n  //       closet.x = -halfExtend.x;\n  //     }\n  //   } else {\n  //     if (closet.y > 0) {\n  //       closet.y = halfExtend.y;\n  //     } else {\n  //       closet.y = -halfExtend.y;\n  //     }\n  //   }\n  // }\n  // const normal = Vec2.sub(n, closet);\n  // let d = normal.lenSqr();\n  // const r = circle.getRadius();\n  // if (d > r * r && !inside) {\n  //   return;\n  // }\n  // m.contacts.push(closet);\n  // d = Math.sqrt(d);\n  // if (inside) {\n  //   m.normal = Vec2.minus(n);\n  //   m.penetration = r - d;\n  // } else {\n  //   m.normal = n;\n  //   m.penetration = r - d;\n  // }\n}\n","import { Body } from \"./body\";\nimport { AABB, Circle } from \"./shape\";\nimport { Vec2 } from \"./vec2\";\nimport { World } from \"./world\";\n\nconst canvas = document.querySelector(\".scene\") as HTMLCanvasElement;\nconst ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\ncanvas.width = 480;\ncanvas.height = 800;\n\nconst world = new World(1 / 60, 20);\n\naddBorder();\n\nconst renderLoop = () => {\n    ctx.fillStyle = \"rgb(45, 64, 108)\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    world.step();\n    for (const body of world.getBodies()) {\n        body.render(ctx);\n    }\n    requestAnimationFrame(renderLoop);\n};\n\nrenderLoop();\n\ncanvas.addEventListener(\"mousedown\", (e) => {\n    if (e.button === 0) {\n        // 左键被按下，在按下的位置生成一个Ball\n        const rect = canvas.getBoundingClientRect();\n        const ballPosition = new Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        world.add(new Body(new Circle(30), ballPosition, 1.0));\n    } else if (e.button === 2) {\n        // 右键被按下，在按下的位置生成一个AABB\n        const rect = canvas.getBoundingClientRect();\n        const pos = new Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        const aabb = new AABB(new Vec2(0, 0), new Vec2(60, 60));\n        world.add(new Body(aabb, pos, 1.0));\n    }\n});\n\nfunction addBorder() {\n    const bottomHeight = 20;\n    const otherHeight = 10;\n    const topBorderAABB = new AABB(new Vec2(0, 0), new Vec2(canvas.width, otherHeight));\n    const topBorderground = new Body(topBorderAABB, topBorderAABB.getCenter(), 0.5);\n    topBorderground.makeStatic();\n    world.add(topBorderground);\n    const bottomBorderAABB = new AABB(new Vec2(0, canvas.height - bottomHeight), new Vec2(canvas.width, canvas.height));\n    const bottomBorderGround = new Body(bottomBorderAABB, bottomBorderAABB.getCenter(), 0.5);\n    bottomBorderGround.makeStatic();\n    world.add(bottomBorderGround);\n    const leftBorderAABB = new AABB(new Vec2(0, otherHeight), new Vec2(otherHeight, canvas.height - bottomHeight));\n    const leftBorderAABBGround = new Body(leftBorderAABB, leftBorderAABB.getCenter(), 0.5);\n    leftBorderAABBGround.makeStatic();\n    world.add(leftBorderAABBGround);\n    const rightBorderAABB = new AABB(new Vec2(canvas.width - otherHeight, otherHeight), new Vec2(canvas.width, canvas.height - bottomHeight));\n    const rightBorderGround = new Body(rightBorderAABB, rightBorderAABB.getCenter(), 0.5);\n    rightBorderGround.makeStatic();\n    world.add(rightBorderGround);\n}\n","import { Body } from \"./body\";\nimport { Manifold } from \"./manifold\";\nimport { Vec2 } from \"./vec2\";\n\nexport class World {\n  private dt: number;\n  private iterations: number;\n  private bodies: Array<Body> = [];\n  private contacts: Array<Manifold> = [];\n  private gravityScale = 10.0;\n  private gravity = new Vec2(0, 10.0 * this.gravityScale);\n\n  constructor(dt: number, iterations: number) {\n    this.dt = dt;\n    this.iterations = iterations;\n  }\n\n  getBodies() {\n    return this.bodies;\n  }\n\n  step() {\n    this.contacts.length = 0;\n    // 碰撞检测\n    for (let i = 0; i < this.bodies.length; ++i) {\n      const a = this.bodies[i];\n      for (let j = i + 1; j < this.bodies.length; ++j) {\n        const b = this.bodies[j];\n        if (a.inverse_mass === 0 && b.inverse_mass === 0) {\n          // 两个物体的质量都是无穷大，都不会挪动了\n          continue;\n        }\n        const m = new Manifold(a, b);\n        m.solve();\n        if (m.contacts.length > 0) {\n          this.contacts.push(m);\n        }\n      }\n    }\n\n    for (let i = 0; i < this.bodies.length; ++i) {\n      this.integrateForces(this.bodies[i], this.dt);\n    }\n\n    for (let i = 0; i < this.contacts.length; ++i) {\n      this.contacts[i].initialize();\n    }\n\n    for (let j = 0; j < this.iterations; ++j) {\n      for (let i = 0; i < this.contacts.length; ++i) {\n        this.contacts[i].applyImpulse();\n      }\n    }\n\n    for (const body of this.bodies) {\n      this.integrateVelocity(body, this.dt);\n    }\n\n    // 校正位置\n    for (const contact of this.contacts) {\n      contact.positionalCorrection();\n    }\n\n    // 清除所有受力\n    for (const body of this.bodies) {\n      body.force = new Vec2(0, 0);\n    }\n  }\n\n  add(body: Body) {\n    this.bodies.push(body);\n  }\n\n  private integrateForces(body: Body, dt: number) {\n    if (body.inverse_mass === 0) {\n      return;\n    }\n\n    body.velocity = Vec2.add(\n      body.velocity,\n      Vec2.product(\n        Vec2.add(Vec2.product(body.force, body.inverse_mass), this.gravity),\n        dt / 2\n      )\n    );\n  }\n\n  private integrateVelocity(body: Body, dt: number) {\n    if (body.inverse_mass === 0) {\n      return;\n    }\n    body.position = Vec2.add(body.position, Vec2.product(body.velocity, dt));\n    // TODO: Why ??\n    this.integrateForces(body, dt);\n  }\n}\n"],"names":["Vec2","constructor","x","y","this","clone","add","left","right","equal","sub","product","dot","div","clampNumber","value","min","max","clamp","minus","vec","normalize","length","distance","isNaN","console","error","lenSqr","Math","sqrt","pow","ShapeType","Circle","radius","shapeType","density","computeMass","PI","getRadius","AABB","getCenter","Body","shape","position","restitution","velocity","force","mass","inverse_mass","applyForce","f","applyImpulse","impulse","makeStatic","renderCircle","ctx","circle","beginPath","fillStyle","arc","fill","renderAABB","rect","halfExtend","leftTop","fillRect","render","DISPATCHER","Map","m","a","b","circleA","circleB","n","r","dist_sqr","dist","penetration","normal","contacts","push","AABB2circle","firstAABB","secondAABB","aExtent","bExtent","xOverlap","abs","yOverlap","Manifold","e","solve","func","get","Error","initialize","infiniteMassCorrection","rv","inv_mass_sum","j","positionalCorrection","aabb","difference","clamped","closet","canvas","document","querySelector","getContext","width","height","world","dt","iterations","bodies","gravityScale","gravity","getBodies","step","i","integrateForces","body","integrateVelocity","contact","topBorderAABB","topBorderground","bottomBorderAABB","bottomBorderGround","leftBorderAABB","leftBorderAABBGround","rightBorderAABB","rightBorderGround","addBorder","renderLoop","requestAnimationFrame","addEventListener","button","getBoundingClientRect","ballPosition","clientX","clientY","top","pos"],"sourceRoot":""}